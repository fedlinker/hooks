(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{jz1k:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return c})),t.d(n,"default",(function(){return u}));var a=t("Fcif"),i=t("+I+c"),l=(t("mXGw"),t("/FXl")),o=t("TjRS"),r=t("ASj2"),c=(t("aD51"),{});void 0!==c&&c&&c===Object(c)&&Object.isExtensible(c)&&!c.hasOwnProperty("__filemeta")&&Object.defineProperty(c,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"docs/useNextFrame.mdx"}});var b={_frontmatter:c},s=o.a;function u(e){var n=e.components,t=Object(i.a)(e,["components"]);return Object(l.b)(s,Object(a.a)({},b,t,{components:n,mdxType:"MDXLayout"}),Object(l.b)("h1",{id:"usenextframe"},"useNextFrame"),Object(l.b)("p",null,"This hook ensures that the ",Object(l.b)("inlineCode",{parentName:"p"},"fn")," function is invoked after the current browser painting. Usually used to perform CSS animation."),Object(l.b)("h2",{id:"usage"},"Usage"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"function useNextFrame(\n  fn: () => void,\n  options?: { imperative?: boolean; disabled?: boolean }\n): [start: () => void, cancel: () => void];\n")),Object(l.b)("p",null,"Params:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"strong"},"fn"),":")," function expected to be executed."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"strong"},"options.imperative"),":")," disable automatically calling the ",Object(l.b)("inlineCode",{parentName:"li"},"fn")," when the component is mounted."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"strong"},"options.disabled"),":")," disable calling the ",Object(l.b)("inlineCode",{parentName:"li"},"fn")," anytime.")),Object(l.b)("p",null,"Return:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"strong"},"start"),":")," set a timer to excute the ",Object(l.b)("inlineCode",{parentName:"li"},"fn")," function after current painting."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"strong"},"cancel"),":")," cancel the timer.")),Object(l.b)("h2",{id:"example"},"Example"),Object(l.b)(r.a,{mdxType:"Example"}),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),'import React, { useState } from "react";\nimport { useNextFrame, useTimeout } from "@fedlinker/hooks";\n\nconst duration = 1000;\n\nfunction Example() {\n  const [display, setDisplay] = useState(false);\n  const [visible, setVisible] = useState(false);\n\n  const [startVisible, cancelVisible] = useNextFrame(\n    () => {\n      setVisible(true);\n    },\n    { imperative: true }\n  );\n\n  const [startHide, cancelHide] = useTimeout(\n    () => {\n      setDisplay(false);\n    },\n    duration,\n    { imperative: true }\n  );\n\n  function handleShowClick() {\n    cancelHide();\n    setDisplay(true);\n    startVisible();\n  }\n\n  function handleHideClick() {\n    cancelVisible();\n    setVisible(false);\n    startHide();\n  }\n\n  return (\n    <div>\n      <button onClick={handleShowClick}>Show</button>\n      <button onClick={handleHideClick}>Hide</button>\n      <div\n        style={{\n          display: display ? "block" : "none",\n          opacity: visible ? 1 : 0,\n          transition: `opacity ease ${duration / 1000}s`,\n          width: 100,\n          height: 100,\n          backgroundColor: "cyan",\n        }}\n      ></div>\n    </div>\n  );\n}\n\nexport default Example;\n')))}void 0!==u&&u&&u===Object(u)&&Object.isExtensible(u)&&!u.hasOwnProperty("__filemeta")&&Object.defineProperty(u,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"docs/useNextFrame.mdx"}}),u.isMDXComponent=!0}}]);
//# sourceMappingURL=component---docs-use-next-frame-mdx-5913e17be6df65095500.js.map